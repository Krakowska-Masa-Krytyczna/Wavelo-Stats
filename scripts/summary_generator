#!/usr/bin/env python3

import argparse
from datetime import datetime, tzinfo, timezone
import metar
from metar import Metar
import re
import time
import urllib.request
import yaml
try:
    from yaml import CLoader as Loader
except ImportError:
    from yaml import Loader, Dumper

from collections import Counter

parser = argparse.ArgumentParser()
parser.add_argument('-d', '--data', nargs='+', type=str, help='data filenames', dest='data_fnames')
parser.add_argument('-f', '--from', nargs=1, default=None, type=str, help='start time (localtime, YYYY-mm-dd HH:MM:SS)', dest='t0')
parser.add_argument('-t', '--to', nargs=1, default=None, type=str, help='end time (localtime, YYYY-mm-dd HH:MM:SS)', dest='t1')
parser.add_argument('output', metavar='output', type=str)
args = parser.parse_args()

raw_data = {}

for data_fname in args.data_fnames:
    with open(data_fname, 'r') as data_file:
        raw_data.update(yaml.load(data_file, Loader=Loader))

for k in sorted(raw_data.keys()):
    if 'bikes' not in raw_data[k]:
        del raw_data[k]
    
t0 = args.t0 
if t0 == None:
    t0 = sorted(raw_data.keys())[0]
else:
    t0 = t0[0]

t1 = args.t1
if t1 == None:
    t1 = sorted(raw_data.keys())[-1]
else:
    t1 = t1[0]

t0 = int(time.mktime(datetime.strptime(t0, "%Y-%m-%d %H:%M:%S").timetuple()))
t1 = int(time.mktime(datetime.strptime(t1, "%Y-%m-%d %H:%M:%S").timetuple()))

utc0 = datetime.utcfromtimestamp(t0).utctimetuple()
utc1 = datetime.utcfromtimestamp(t1).utctimetuple()

metars = {}
with urllib.request.urlopen('http://www.ogimet.com/display_metars2.php?lang=en&lugar=EPKK&tipo=SA&ord=REV&nil=NO&fmt=txt&ano=%d&mes=%d&day=%d&hora=%d&min=%d&anof=%d&mesf=%d&dayf=%d&horaf=%d&minf=%d&send=send' % (utc0.tm_year, utc0.tm_mon, utc0.tm_mday, utc0.tm_hour, utc0.tm_min, utc1.tm_year, utc1.tm_mon, utc1.tm_mday, utc1.tm_hour, utc1.tm_min)) as f:
    data = f.read().decode('utf-8').replace('\n', ' ')
    for m in re.finditer('METAR EPKK[^=]+', data):
        metar = Metar.Metar(m.group(0))
        metar.time = metar.time.replace(tzinfo=timezone.utc)
        metars[metar.time.astimezone().strftime('%Y-%m-%d %H:%M:%S')] = metar

hubs_data = {}
bikes_data = {}
hubs = {}
bikes = {}

prev_ts = None
max_dt = None

for k in sorted(raw_data.keys()):
    ts = raw_data[k]['timestamp']
    if ts < t0 or ts > t1:
        continue

    h = raw_data[k]['hubs']
    hubs_data[ts] = h
    for hk in h.keys():
        if not hk in hubs:
            hubs[hk] = {'id': h[hk]['id'], 'name': h[hk]['name'], 'rentals': 0, 'returns': 0}
    b = raw_data[k]['bikes']
    bikes_data[ts] = b
    for bk in b.keys():
        if not bk in bikes:
            bikes[bk] = {'id': b[bk]['id'], 'name': b[bk]['name'], 'rentals': 0, 'returns': 0}

    if not prev_ts is None:
        dt = ts - prev_ts
        if max_dt is None:
            max_dt = dt
        if dt > max_dt:
            max_dt = dt

    prev_ts = ts

hubs[None] = {'id': None, 'name': 'out_of_station', 'rentals': 0, 'returns': 0}

del raw_data

rented = {}
trips = Counter()
rental_times = []

res = {
    't0': datetime.fromtimestamp(t0).strftime('%Y-%m-%d %H:%M:%S'),
    't1': datetime.fromtimestamp(t1).strftime('%Y-%m-%d %H:%M:%S'),
    'meteo': {},
    'total_time': t1 - t0,
    'max_dt': max_dt,
    'bikes_accounted_for': len(bikes),
    'total_rentals': 0,
    'total_returns': 0
    }

temps = []
weathers = []
skies = []

for d in metars:
    metar = metars[d]
    res['meteo'][d] = { 'metar': metar.code, 'temp': metar.temp.value('C'), 'dewpt': metar.dewpt.value('C'), 'wind_speed': metar.wind_speed.value('KMH'), 'vis': metar.vis.value('M') }
    temps.append(metar.temp.value('C'))
    if metar.weather:
        res['meteo'][d]['weather'] = metar.present_weather()
    if metar.sky:
        res['meteo'][d]['weather'] = metar.sky_conditions()
    t = metar.time
    if t >= t.replace(hour=8, minute=0, second=0, microsecond=0) and t <= t.replace(hour=22, minute=0, second=0, microsecond=0):
        if metar.weather:
            weathers.append(metar.weather)
        if metar.sky:
            skies.append(metar.sky)

thunderstorm = False
rain = 0
cloud = 0

for w in weathers:
    for e in w:
        if e[1] == 'TS':
            thunderstorm = True  
        if rain < 2 and e[0] != '-' and e[2] == 'RA':
            rain = 2
        if rain < 1 and (e[0] == '-' and e[2] == 'RA' or e[2] == 'DZ'):
            rain = 1

for s in skies:
    for e in s:
        if cloud < 2 and (e[0] == 'BKN' or e[0] == 'OVC' or e[0] == 'VV'):
            cloud = 2
        if cloud < 1 and (e[0] == 'FEW' or e[0] == 'SCT'):
            cloud = 1
    
wi = 'day-sunny'

if thunderstorm:
    wi = 'thunderstorm'
    if cloud < 2:
        wi = 'day-thunderstorm'
else:
    if rain > 1:
        wi = 'rain'
        if cloud < 2:
            wi = 'day-rain'
    elif rain > 0:
        wi = 'sprinkle'
        if cloud < 2:
            wi = 'day-sprinkle'
    else:
        if cloud > 1:
            wi = 'cloudy'
        elif cloud > 0:
            wi = 'day-cloudy'
        
res['weather_icon'] = wi
res['min_temp'] = min(temps)
res['max_temp'] = max(temps)
        
pb = bikes_data[sorted(bikes_data.keys())[0]]
for ts in sorted(bikes_data.keys()):
    b = bikes_data[ts]

    for bk in pb.keys():
        if (not bk in b) or (bk in b and pb[bk]['hub_id'] != b[bk]['hub_id']):
            hubs[pb[bk]['hub_id']]['rentals'] += 1
            rented[bk] = { 'from': pb[bk]['hub_id'], 'timestamp': ts }
            res['total_rentals'] += 1

    for bk in b.keys():
        if (not bk in pb) or (bk in pb and b[bk]['hub_id'] != pb[bk]['hub_id']):
            hubs[b[bk]['hub_id']]['returns'] += 1
            if bk in rented:
                trips[(rented[bk]['from'], b[bk]['hub_id'])] += 1
                rental_times.append(ts - rented[bk]['timestamp'])
                del rented[bk]
            res['total_returns'] += 1

    pb = b

res['hubs'] = hubs
res['trips'] = []

for t in trips.most_common():
    res['trips'].append({'from': t[0][0], 'to': t[0][1], 'count': t[1]})

res['complete_rentals'] = len(rental_times)
res['spurious_rentals'] = sum(t == 0 for t in rental_times)
rental_times = [t for t in rental_times if t != 0]
res['short_rentals'] = sum(t <= 1200 for t in rental_times)
res['medium_rentals'] = sum(t > 1200 and t <= 3600 for t in rental_times)
res['long_rentals'] = sum(t > 3600 and t <= 5400 for t in rental_times)
res['xlong_rentals'] = sum(t > 5400 for t in rental_times)
res['shortest_rental'] = min(rental_times)
res['longest_rental'] = max(rental_times)
res['average_rental'] = sum(rental_times) / float(len(rental_times))

with open(args.output + '_summary.yaml', 'w') as out:
    yaml.dump(res, out, allow_unicode = True, default_flow_style = False)

with open(args.output + '_summary_trips.yaml', 'w') as out:
    yaml.dump({k: res[k] for k in ('t0', 't1', 'max_dt', 'hubs', 'trips')}, out, allow_unicode = True, default_flow_style = False)

with open(args.output + '_summary_short.yaml', 'w') as out:
    yaml.dump({k: res[k] for k in res if type(res[k]) in (str, int, float)}, out, allow_unicode = True, default_flow_style = False)

